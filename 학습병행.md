## 개발 노트

#### 개발 1일차 정리

- 프로젝트 구성 및 초기 theme상태 정의
- theme 타입 구성 후 themeProvider로 전역변수 설정

#### 개발 2일차 정리 및 피드백(with gemini)

Q: "아톰으로 전역을 관리할 data생성, data는 배열형태(투두아이템들이 들어가야하니)",
A: 완벽합니다. todoListState 아톰이 ITodoItem[] 형태의 전역 저장소 역할을 합니다.

Q: 이를 위해 아톰을 위한 인터페이스 생성(오류방지),"
A: 완벽합니다. 인터페이스는 TypeScript의 기능으로, 아톰에 들어갈 데이터의 형태(타입)를 정의하여 오류를 미리 방지합니다.

Q: "입력로직,,useForm의 register로 등록된 인풋값을,, onValid 함수로 검증해서 register에 등록, 이때 아이템의 형태는 Iform에 정의한 형태로 받음,, form 입력값 받는 부분은 useForm의 handlesubmit으로 제어"
A: ⭐️ 거의 완벽합니다. 인풋 값을 onValid로 검증하는 것이 아니라, handleSubmit이 인풋 값을 수집하고, onValid 함수가 수집된 값을 인수로 받습니다. (검증은 register의 두 번째 인자에서 정의됩니다.)

Q: 이후, 입력이 발생할때 마다 map으로 list 생성,, key는 입력되는 item의 id(id = date.new())"
A: 아주 정확합니다. toDos 배열이 바뀔 때마다 **map**을 통해 UI를 다시 그리고, key로 **todo.id**를 사용합니다."

Q: 삭제는 개별 아이템이 가진 아이디를 타겟으로,, 너가 알려준데로 map생성 시 클로저 함수를 삭제버튼에 달아서,,입력되는 아이템들의 id를 저장하게함."
A: ⭐️ 클로저 이해 완벽! 렌더링 시점에 **개별 todo.id를 기억(캡처)**하는 새로운 함수를 생성하여 onClick에 연결하는 로직입니다.

Q: "이걸 삭제로직으로 즉,기존 투두배열에서 이 삭제아이디와 일치하지 않는 아이템들만 추려 새로운 배열로 만들기 구현"
A: filter()를 사용해 불변성을 지키면서 원하는 아이템만 제외한 새 배열을 만들어 Recoil 상태를 업데이트하는 핵심 로직입니다.

---

#### 개발 3일차 정리 및 피드백(with gemini)

- 생성한 TodoBoard의 Css 및 애니메이션을 마무리함.

  - 추후 update 희망사항: 라이트/다크모드 애니메이션 슬라이드로 수정

- 🔥 kanban로직의 이해 어려움

  - 리스트 아이템의 내용을 수정하는 것, ui를 업데이트 후 recoil을 수정해야 함.(개념정립이 어려웠음)
    - ui를 업데이트 하려면 로컬 state가 필요(useState)
    - 이 로컬 state는 별도의 컴포넌트가 관리해야 코드가 깔끔해짐, 성능향상

- 단일보드 투두앱의 로직과 kanban보드 로직을 헷갈려 리팩터링 진행

  - atom data구조 재설계
  - 핵심코드: `...allBoard : 전체 보드 묶음(원본), ...allBoard[boardId] : 특정 보드만 꺼냄()`

- 이래저래 안되는 부분이 많음.. 휴식

---

#### 개발 4일차 정리 및 리뷰

- 가장 중요한 건 지금코드리뷰 및 강의 리뷰가 필요

- 리팩터링 마무리
  - 수정/삭제 로직 구현
    - ui 업데이트: card
    - recoil 업데이트: board
    - maincontent :
- 단일보드 리스트 추가시 모든 리스트가 업데이트 되는 문제를 겪음
  - 해결: Css에서 display를 grid를 flex로 변경 및 align-item을 변경해 보드 개별적 높이를 자신의 내용물에 맞추게 함.
- 내용 수정 시 더블 클릭으로 진입시, 취소가 키보드로 이루어 지지 않고, 포커스를 잃었을 경우, 수정 취소가 안되는 문제
  - keyboard Event를 통한 함수로 "escape" 시, 수정 취소되게 함
  - onBlur로 outFocus시 수정이 취소되게함

#### 개발 5일차 정리 및 리뷰

- 지금 내가 어디로 가고 있는지 헷갈림.
- 수정/삭제 로직은 ui업데이트/recoil업데이트로 나뉘는데.. ui는 하위 컴포넌트가(업데이트당할), recoil은 상위 컴포넌트(업데이트 요소를 포함하는)가 담당

  - 아이템 수정/삭제 로직과, 보드명 수정/삭제 로직이 대동소이함.
  - 이번에는 직접 보드명 수정/삭제 로직을 구현해보고자함..

- 보드 타이틀 수정을 위해, 별도의 컴포넌트 생성(복잡도를 낮추고 useForm을 사용하기 위에 board>editBoardTitle)
  - BoardTitleEditor.tsx는 form을 업데이트
    - useForm을 이용해 form/input관리
    - form이 board에 중복으로 있을 수 없어서 분리함.
    - 추가로 키보드 이벤트/onBlur 구성,
  - board는 ui를 업데이트
    - useState로 isEditin상태 구성, editTitle에 prop으로 boardId, 수정함수 제공
  - main은 recoil을 업데이트

---

#### 개발 6일차 정리 및 리뷰

- BoardTittleEditor.tsx 에 보드명 수정을 위한 form/input관리 구축
- Board.tsx 에서 uiUpdate로직과 prop 전달로직 구현 - boardTtitle과 main의 중계역할

- 코드리뷰:

```javascript
setToDos((allBoard) => {
      1. const boardToUpdate = allBoard[oldId];
      2. const { [oldId]: _, ...resetBoards } = allBoard; //객체구조분해할당을 이용한 특정 키 제거
      3. const newAllBoard = {
            ...resetBoards,
            [newId]: boardToUpdate,
        };
    return newAllBoard;
```

1. 기존보드[oldId]에 저장된 할일들(todo)를 boardToUpdate 변수에 저장함
2. 객체 구조 분해 할당으로 allBoard 객체에서 oldId에 해당하는 키-값 쌍을 분리
   1. oldId의 값은 \_(무시 변수)에 담아, 삭제
   2. 나머지 모든 보드들은 ...resetBoards에 담아 새로운 객체 생성
   3. 즉, allBoard에서 oldId를 추출(제외), 나머지는 resetBoard에 담음

- 🔥 핵심문법: const { [keyToRemove]: \_, ...rest } = obj;
  obj에서 keyToRemove를 제거한 새 객체(rest)를 만드는 패턴

- 보드 삭제/추가와 드래그 앤 드롭만 남겨두고 있음.. 전체적을 코드리뷰가 필요함
  - 어떤 것을 모르는지. 어떤것을 헷갈리는지 확인하고 넘어가야 함..

---

#### 개발 7일차 정리 및 리뷰

- 보드 삭제로직 구현,,

  - 핵심은 boardDelete시 RecoilUpdate가 UI업데이틈임을 배움
    - 따라서.. board.tsx에는 main으로 부터 받은 prop만을 버튼에 연결
  - main에서 보드 삭제(recoil update)코드를 작성
    - `핵심코드: const{[boardId]:_, ...resetBoard} = allBoard;`
    - 기존의 allBoard에서 boardId(클릭시 삭제될 boardId를 인자제공,)를 추적해, resetBoard에 담아 반환함

- 보두 추가로직 구현

  - 보드추가 버튼이 header에 있어 maincontent와는 형제여서 원래라면 prop drilling이 필요함
  - 하지만, recoil사용으로 같은 atom을 볼 수 있기 때문에 propDrilling을 회피할 수 있음
  - 보드 추가는 id(date.now)/text필요없이 board이름만,, 보드이름이 id임.
  - 또,, input이 필요하니깐.. useForm을 submit 및 등록을 관리가 필요함
  - 입력/취소 상태를 위해 useState사용
  - input에서 키보드로 바져나오기 위해 keydonw => input
  - onBlur로 취소상태 구현(마우스)

- 해야할 일
  - 보드 추가 취소시 빠져나오는 에니메이션 variants 구성(animatePresence)
  - input 박스 스타일링
  - 기타: 중복된 항목이 있을 경우, 알림 Push 구형
    - 입력 및 취소 시 확인 Push 구현
  - DnD구현

-코드리뷰 및 복습(빠르게 기능을 구현해보기)

---

#### 개발 8일차 정리 및 리뷰

- 할일(7일차 이어받음)

  - input 애니메이션 정리
    - input 정리 이전에,, 아이콘 팩 변경 fontAwesom에서 lucide react로,,
    - 이에 따른 코드 정리 중,, dargableItem의 애니메이션 오류발견
      - 구현방향: 아이템 리스트(box) hover 시,, 수정/삭제 버튼 보이게 끔, 아이콘 상태 채움으로 테마 변경효과 향상,
        - 해결: 부모의 variants를 자식에게 전달하기 위해,,자식은 variants만 정의함(전파)
      - ~~구현방향2, 텍스트 수정을 아이템 박스를 클릭스로 가능하다면,, 변경~~,, -> 복잡도가 올라가 취소함
  - 이후, input 및 기타 아이콘 수정,,
    - input수정에 앞서,, toDo입력 부분의 퇴장로직이 없음
      - esc를 통해, 입력폼의 값을 처음으로 돌림
      - 마우스를 통한 입력폼 초기화 역시 onBlur로 구현
      - 보드명 수정 시 form의 형태를 다른 형태와 동일하게 유지하기 위해 CSS적용
    - input 수정 전, 보드 아이콘에 variants 적용을 위해 고민했으나 복잡도 상승으로 포기, reference도 css사용
      - 취소함
    - board 및 아이템 delete시 경고 모달 구현 - `if(window.confirm()){}`으로 구현

- 못한 일
  - 시간 부족으로 input(보드추가) 애니메이션 구현 못함
    - gemini의 도움으로 해결,, 애니메이션이 구현되려면(animtePresence) 각 요소는 key를 가져야 함
    - animatePresence의 중요한 point
  - 보드 여러개 추가시 정렬(grid로 해야할 겉 같은데..)
  - 포기한 부분: button관련 애니메이션 hover, 배경색
  -
  - 개발 8일차 혹은 9일차에 dnd구현 예정

#### 개발 9일차 정리 및 리뷰

- 애니메이션 마무리
  - header의 input과 plus의 애니메이션 꼬임은
    - animatePrescence의 mode=wait으로 해결함 - chatGPT도움
    - 애니메이션 부분은 거의 마무리인듯,, 기타 자잘한 문제는 프로젝트 완성 후 수정
- DnD 구현
  - dnd-kit로 구현방법을 결정, 강의와 다른 라이브러리여서(강의는 RBD)여서 적응에 시간이 걸릴듯..
- 남은 과제.. dnd구현 후 타이머 생성/ 기타 버그수정

#### 개발 10일차 정리 및 리뷰

-dnd kit으로 시작

- DndContext를 위한 onDragEnd함수 구현 - mainContents.tsx

  - over.id,actve.id로 유효성검사
  - indexOf로 이동한 혹은 이동된 id를 index를 추적
  - arrayMove로(dnd-kit HelperFn) 보드간 이동 시 새 배열 생성(순서가 바뀐) -`arrayMove(대상, from, to)`
  - arrayMove로 생성된 아이디를 가지고 새로운 배열을 만듬 `reduce()` - 이게 좀헷갈림
    - 불변성은 유지, 새 객체 생성

- Board.tsx에 useSortable훅을 import

  - 속성은 setNodeRef(필수), listener(필수), transform/transition(필수) 로드
    - listener는 실제 drag로 이벤트 발생시 필수요소

- 보드 드래그 애니메이션이 꼬임이 발생,, 다시 수정하면서 복습하기로.

#### 개발 11일차 정리 및 리뷰

- atom의 data구조 변경

  - 기존 구조는 title자체가 id역할을 수행 보드제목 수정시 key를 변경
    - 때문에 key를 삭제하고 새 key로 객체를 전체 생성해야 하는 번거로움
    - dnd-kit 애니메이션 꼬임의 원인이 되는 것 같아
      - 순서변경 역시, Object.key로 순서를 뽑아 reduce로 객체를 순서대로 다시생성,, 번거로움
  - id 속성이 별도로 제공,
    - 보드명 수정시 id는 그대로 두고,, title속성만 변경(데이터 옮길 필요없음) -잘 이해가 되지 않지만,, 일단 진행,, 유리해보이기는 함

- 모르는 것,, 컴포넌트가 많아지니.. prop들의 흐름이 눈에 보이지 않음
- 일단 오늘 배운 recoil update(추가/삭제/수정)의 핵심로직 복습
  - 기존의 객체에서 배열로 변경되면 map으로 새보드 생성 및 업데이트..
  - dnd로직 단순화,, 배열이기 때문에 간단해짐
  - 왜 배열이어서 단순해졌지? 암튼.. 복습은 밤에
  - 그리고 gemini코드 챌린지 해보기
- 버그: boardTitle 수정부라
  - dnd시 outline 추적대상 부정확

#### 개발 12일차 정리 및 리뷰

- dnd-kit의 드래그 애니메이션 꼬임으로 수정중..
  -isOver: 다른 요소와의 관계(다른 드래그 요소가 내 위에 있는가?)
  -isDragging:나의 상태(현재 움직여지는 요소인가?)

  - 이둘을 헷갈려 애니메이션이 꼬임

- finally.. 아이템의 보드내 움직임/보드간 움직만 남음
  - 로직이 복잡해 보임..
    gemini와 완성한 로직을 다시한번 복습하기..어렵다.

마지막 타이머,, 어떻게든 구현

#### 개발 13일차 정리 및 리뷰

-dnd-kit을 활용 보드 내 아이템이동 구현

- 드래그 핸들을 구현, 아이템 자체를 드래그하는 방향으로..
- TodoBoard.tsx에서 toDoItem을 sortableContext로 감쌈 - 정렬영역생성
- 카드 드래그시 Css구현..-> css가 아닌 dragoverlay 컴포넌트를 추가해, 카드상태를 관리해야 함.
- .flatMap()과 .find()로 활성 요소 추적
- DragOverlay 컴포넌트 는 dndcontext 내부에 있어야 정확한 dnd-kit 계산이 됨

- isOverlay props..
- 모든 프로젝트 완성 후 간단한 예제로 복습이 필요할 듯

-버그,, 아이템이 찬 보드는 이동대상에서 제외가(?)됨.. 왜일가??
-dnd kit의 해결책

- 보드는 영역을 줄이고,, 이동 시 작은 박스만 보이게 했음 - 이거 진짜 모르겠다.

#### 개발 14일차 정리 및 리뷰

- 다른 보드로의 card이동 구현
  - 다른 보드로의 카드 이동이 구현되었으나,, 같은 보드 내 카드 이동이되지 않음
  - 원인은 mainContents.tsx의 oldIndex와 newIdex의 타입 불일치
  - number 타입으로 data를 받음 -> dnd-kit은 string으로 처리
  - id를 비교하기전 명시적으로 string으로 변환해 주어 오류 해결- github-coplit 으로 해결함
- 최종 완성 후 코드리뷰

#### 개발 15일차 정리 및 리뷰

- 전체 코드리뷰 및 리팩터링
  - mainContents.tsx의 dnd로직 리팩터링
    - arrayMove를 통한 새로운 배열 생성 후 reduce로 객체생성은 불필요
    - dnd-kit의 제공하는 moveItemInArray, moveItemBetweenArrays를 활용해 불변성 유지하며 간단하게 구현
  - Board.tsx의 useSortable 훅 리팩터링
    - transform/transition을 style에 직접 할당하지 않고,, useTransform 훅을 활용해 간단하게 구현
- 기타 자잘한 버그 수정 및 스타일링 마무리

변수명,추적 대상,타입,논리적 역할>
activeId,드래그를 시작한 요소,string,DndContext에서 받은 최초 드래그 요소의 ID (보드 ID 또는 카드 ID).
overId,드롭된 위치의 요소,string,DndContext에서 받은 드롭된 위치 요소의 ID (다른 보드 ID 또는 다른 카드 ID).
activeIdStr,activeId,string,active.id를 문자열로 형 변환한 값 (편의상 사용).
overIdStr,overId,string,over.id를 문자열로 형 변환한 값 (편의상 사용).
activeType,드래그 요소의 유형,"""card"" 또는 undefined",드래그 요소가 보드인지 카드인지 구분하는 기준.
activeBoardId,드래그 요소가 속한 보드 ID,string,activeIdStr가 보드 ID일 경우. (보드 이동 로직에서 사용)
overBoardId,드롭 위치의 보드 ID,string,"overIdStr가 카드 ID일 경우, **findCardContainer**를 통해 해당 카드가 속한 보드 ID를 찾아냅니다."
activeContainerId,드래그 카드가 속한 보드 ID,string,moveCard 함수 내부에서 **findCardContainer**를 통해 찾은 시작 보드 ID.
overContainerId,드롭 위치 카드가 속한 보드 ID,string,moveCard 함수 내부에서 **findCardContainer**를 통해 찾은 목표 보드 ID.
